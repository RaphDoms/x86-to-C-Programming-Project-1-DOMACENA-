C-PROGRAMMING

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Define kernel functions
void c_kernel(float *A, float *B, int n, float *sdot) {
    // Implement the C version of the dot product kernel
}

void asm_kernel(float *A, float *B, int n, float *sdot) {
    // Implement the x86-64 assembly version of the dot product kernel
}

// Function to initialize vectors with random values
void initialize_vectors(float *A, float *B, int n) {
    // Implement vector initialization with random values
}

// Function to compare output of C and assembly versions
int compare_outputs(float *sdot_c, float *sdot_asm, int n) {
    // Implement output comparison
    // Return 1 if outputs match, 0 otherwise
}

// Function to measure execution time of a kernel
double measure_execution_time(void (*kernel)(float *, float *, int, float *), float *A, float *B, int n, float *sdot) {
    clock_t start_time, end_time;
    start_time = clock();
    
    // Call the kernel function
    kernel(A, B, n, sdot);

    end_time = clock();
    return ((double) (end_time - start_time)) / CLOCKS_PER_SEC;
}

int main() {
    // Define vector sizes
    int sizes[] = {1 << 20, 1 << 24, 1 << 30}; // Adjust if necessary

    // Seed random number generator
    srand(time(NULL));

    // Run for each vector size
    for (int i = 0; i < sizeof(sizes) / sizeof(sizes[0]); i++) {
        int n = sizes[i];

        // Allocate memory for vectors A and B
        float *A = (float *)malloc(n * sizeof(float));
        float *B = (float *)malloc(n * sizeof(float));

        // Initialize vectors with random values
        initialize_vectors(A, B, n);

        // Allocate memory for dot product result
        float sdot_c, sdot_asm;

        // Run C version kernel
        double time_c = measure_execution_time(c_kernel, A, B, n, &sdot_c);

        // Run assembly version kernel
        double time_asm = measure_execution_time(asm_kernel, A, B, n, &sdot_asm);

        // Check correctness of assembly version output
        int is_correct = compare_outputs(&sdot_c, &sdot_asm, n);

        // Print results
        printf("Vector size: %d\n", n);
        printf("C Version Execution Time: %f seconds\n", time_c);
        printf("Assembly Version Execution Time: %f seconds\n", time_asm);
        printf("Correctness check: %s\n", is_correct ? "Passed" : "Failed");

        // Free allocated memory
        free(A);
        free(B);
    }

    return 0;
}

=========================================================================================================
x86-64 Assembly

%include "io64.inc"

section .data
    fmt db "Dot Product: %f", 10, 0

section .text
global main
global dot_product_asm

main:
    ; Initialize stack frame
    push rbp
    mov rbp, rsp
    
    ; Call the dot_product_asm function
    ; Pass parameters: rdi = n, rsi = A, rdx = B, rcx = &sdot
    call dot_product_asm
    
    ; Print the result
    mov rdi, fmt
    mov rax, 0
    call printf64
    ; Exit program
    mov rax, 0
    leave
    ret

dot_product_asm:
    mov r8, 0        ; Initialize sdot to 0
    xor r9d, r9d     ; Loop counter

dot_product_loop:
    cmp r9d, edi     ; Compare loop counter with n
    je dot_product_end  ; Jump to the end if equal

    movss xmm0, [rsi + r9*4]  ; Load A[i] into xmm0
    movss xmm1, [rdx + r9*4]  ; Load B[i] into xmm1
    mulss xmm0, xmm1           ; Multiply A[i] * B[i]
    addss xmm0, [rsp]          ; Add the result to sdot (stored on the stack)
    movss [rsp], xmm0          ; Store the result back to sdot

    inc r9d          ; Increment loop counter
    jmp dot_product_loop  ; Jump back to the loop

dot_product_end:
    movss xmm0, [rsp]  ; Load sdot from the stack to xmm0
    movss [rcx], xmm0  ; Store the final result in sdot
    ret

